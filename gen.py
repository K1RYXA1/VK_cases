# Генератор для чтения и фильтрации файла
# Есть текстовый файл, который может не помещаться в память. В каждой строке файла фраза или предложение: набор слов, разделенных пробелами (знаков препинания нет).

# Генератор должен принимать на вход:

# имя файла или файловый объект;
# список слов для поиска;
# список стоп-слов.
# Генератор перебирает строки файла и возвращает только те из них (строку целиком), где встретилось хотя бы одно из слов для поиска. Если в одной строке сразу несколько совпадений, то вернуть строку надо лишь один раз. Если в строке встретилось слово из списка стоп-слов, то такая строка должна игнорирроваться, даже если там есть совпадения по словам поиска. Поиск совпадений и стоп-слов должен выполняться по полному совпадению слова без учета регистра.

# Например, для строки из файла "а Роза упала на лапу Азора" слово поиска "роза" должно найтись, а "роз" или "розан" - уже нет. В случае той же строки "а Роза упала на лапу Азора", слова-совпадения "роза" и стоп-слова "азора" исходная строка должна будет быть отброщена.

def filter_file(
        file,
        search_words: list,
        stop_words: list = None 
):
    stop_words = [] if stop_words is None else stop_words
    closer = False
    if isinstance(file, str):
        f = open(file, "r", encoding='utf-8')  
        closer = True
    elif hasattr(file, 'read'):
        f = file
    else:
        raise ValueError("Аргумент должен быть строкой или файловым объектом")
    try:
        for line in f:
            line_list = list(map(lambda i: i.lower(), line.split()))
            for word in stop_words:
                if word.lower() in line_list:
                    break
            else:
                for word in search_words:
                    if word.lower() in line_list:
                        yield line.strip('\n')
                        break
    finally:
        if closer:
            f.close()

